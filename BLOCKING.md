# mssql-changefeed: User guide for blocking mode

Please see [README](README.md) for an overview of the mssql-changefeed
library, and a comparison of the *blocking mode* documented below with
the [outbox mode](OUTBOX.md).

## Setup migration

You set up a new feed by calling the `setup_feed` stored procedure,
passing in the name of a table and `@blocking = 1`, in one of your own
migration files.
```sql
exec [changefeed].setup_feed @table = 'myservice.MyEvent', @blocking = 1;
alter role [changefeed.writers:myservice.MyEvent] add member service1;    
```

This stored procedure will generate tables and stored procedures tailored
for your table and allow the `service1` user to publish new events.

Unlike the outbox mode, there is no special support for readers; this is
for you to provide through your table design.

## About shard_id

Below there is a `shard_id` parameter. This can be set to any `int` number.
The usage of a new `shard_id` effectively creates an independent
event feed.

If you do not have very high volumes, simply hard-code `shard_id` to 0 everywhere.

For the blocking mode, the number of partitions needed should be primarily
be affected by how many partitions it is appropriate for consumers to have;
but it could also be used to reduce the time writers are blocked on waiting
for one another on the same partition on average. This wait time should be
a small problem, unless you are using transactions that take a lot of time
to complete.

## Publisher code

The idea is to generate the ULID for your event before you write
the event. So, for instance you may have a table 
similar to this:
```sql
create table myservice.MyEvent(
    Shard smallint not null,
    ULID binary(16) not null,
    UserID bigint not null,
    ChosenShoeSize tinyint not null,
    constraint pk_MyEvent primary key (Shard, ULID)
) with (data_compression = page);
```
To support reading from the feed you should make available a unique
index on `(Shard, ULID)`. In this case we make it the primary key of our table,
but it could also be a secondary key.

To avoid the [power-off issue](POWEROFF.md) we use a server-side transaction
inside the SQL batch in our example:
```sql
-- Quite a lot of boilerplate to do safe error handling in MS-SQL;
-- see Erland Sommarkog's excellent guide one errors for more detail:
-- https://www.sommarskog.se/error_handling/Part1.html
set xact_abort on
begin try
    
    begin transaction

    -- The first thing we do in our transaction is lock our shard for writes by us.
    exec changefeed.[lock:myservice.MyEvent] @shard_id = 0;
    
    -- Proceed with inserting, generating ULIDs in the right order
    insert into myservice.MyEvent (Shard, ULID, UserID, ChosenShoeSize)
    values (0, changefeed.ulid(0), 1234, 42);
        
    commit

end try
begin catch
    if @@trancount > 0 rollback;
    ;throw;
end catch
```

The call to `lock:*` takes a lock so that other writers to the same
shard will block and wait. After this call, it is possible to call
`changefeed.ulid(@i)`.

The parameter `@i` is used to insert several events in the same
transaction. If you only insert a single event, simply pass `0`;
but if you are inserting many you can for instance use `row_number`
to generate a large number of ULIDs:
```sql
insert into myservice.MyEvent (Shard, ULID, UserID, ChosenShoeSize)
select
    i.UserID % 4,
    changefeed.ulid(row_number() over (order by i.UserID)),
    i.UserID,
    i.ChosenShoeSize
from @input as i
```
If you happen to have a 2nd statement in the same database transaction
that needs ULIDs, simply add a large, safe constant like 1000000:
```sql
-- Insert the rows from @secondinput; we assume that there was less than 1000000
-- rows in @input...
insert into myservice.MyEvent (Shard, ULID, UserID, ChosenShoeSize)
select
    i.UserID % 4,
    -- 
    changefeed.ulid(row_number() over (order by i.UserID) + 1000000),
    i.UserID,
    i.ChosenShoeSize
from @secondinput as i
```
Calling `lock:*` allocates 100000000000 (10^11) ULIDs under the hood,
so your constants should stay safely within this range.

Alternatively, you may also call `lock:*` a 2nd time.

To protect yourself from bugs, `changefeed.ulid()` will generate an
error if `lock:*` has not been called first.

## Consumer code

Consumers simply executes queries on the ULID generated by the publisher.
Continuing on the example above:
```sql
declare @cursor binary(16) = (select MaxReadULID from MyStateTable where Shard = 0);

insert into @pageOfData
select top(1000) * from myservice.MyEvent
where ULID > @Cursor and Shard = 0
order by ULID;

begin transaction 
   -- process the @pageOfData

   -- also update the state table in the same transaction:
   update MyStateTable
   set MaxReadULID = (select max(ULID) from @pageOfData)
   where Shard = 0;

commit
```

